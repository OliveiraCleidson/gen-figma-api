/*
Figma API

This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).

API version: 0.20.0
Contact: support@figma.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the LocalVariable type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &LocalVariable{}

// LocalVariable A Variable is a single design token that defines values for each of the modes in its VariableCollection. These values can be applied to various kinds of design properties.
type LocalVariable struct {
	// The unique identifier of this variable.
	Id string `json:"id"`
	// The name of this variable.
	Name string `json:"name"`
	// The key of this variable.
	Key string `json:"key"`
	// The id of the variable collection that contains this variable.
	VariableCollectionId string `json:"variableCollectionId"`
	// The resolved type of the variable.
	ResolvedType string `json:"resolvedType"`
	// The values for each mode of this variable.
	ValuesByMode map[string]LocalVariableValuesByModeValue `json:"valuesByMode"`
	// Whether this variable is remote.
	Remote bool `json:"remote"`
	// The description of this variable.
	Description string `json:"description"`
	// Whether this variable is hidden when publishing the current file as a library.  If the parent `VariableCollection` is marked as `hiddenFromPublishing`, then this variable will also be hidden from publishing via the UI. `hiddenFromPublishing` is independently toggled for a variable and collection. However, both must be true for a given variable to be publishable.
	HiddenFromPublishing bool `json:"hiddenFromPublishing"`
	// An array of scopes in the UI where this variable is shown. Setting this property will show/hide this variable in the variable picker UI for different fields.  Setting scopes for a variable does not prevent that variable from being bound in other scopes (for example, via the Plugin API). This only limits the variables that are shown in pickers within the Figma UI.
	Scopes []VariableScope `json:"scopes"`
	CodeSyntax VariableCodeSyntax `json:"codeSyntax"`
	// Indicates that the variable was deleted in the editor, but the document may still contain references to the variable. References to the variable may exist through bound values or variable aliases.
	DeletedButReferenced *bool `json:"deletedButReferenced,omitempty"`
}

type _LocalVariable LocalVariable

// NewLocalVariable instantiates a new LocalVariable object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewLocalVariable(id string, name string, key string, variableCollectionId string, resolvedType string, valuesByMode map[string]LocalVariableValuesByModeValue, remote bool, description string, hiddenFromPublishing bool, scopes []VariableScope, codeSyntax VariableCodeSyntax) *LocalVariable {
	this := LocalVariable{}
	this.Id = id
	this.Name = name
	this.Key = key
	this.VariableCollectionId = variableCollectionId
	this.ResolvedType = resolvedType
	this.ValuesByMode = valuesByMode
	this.Remote = remote
	this.Description = description
	this.HiddenFromPublishing = hiddenFromPublishing
	this.Scopes = scopes
	this.CodeSyntax = codeSyntax
	var deletedButReferenced bool = false
	this.DeletedButReferenced = &deletedButReferenced
	return &this
}

// NewLocalVariableWithDefaults instantiates a new LocalVariable object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewLocalVariableWithDefaults() *LocalVariable {
	this := LocalVariable{}
	var deletedButReferenced bool = false
	this.DeletedButReferenced = &deletedButReferenced
	return &this
}

// GetId returns the Id field value
func (o *LocalVariable) GetId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Id
}

// GetIdOk returns a tuple with the Id field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Id, true
}

// SetId sets field value
func (o *LocalVariable) SetId(v string) {
	o.Id = v
}

// GetName returns the Name field value
func (o *LocalVariable) GetName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Name
}

// GetNameOk returns a tuple with the Name field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Name, true
}

// SetName sets field value
func (o *LocalVariable) SetName(v string) {
	o.Name = v
}

// GetKey returns the Key field value
func (o *LocalVariable) GetKey() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Key
}

// GetKeyOk returns a tuple with the Key field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetKeyOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Key, true
}

// SetKey sets field value
func (o *LocalVariable) SetKey(v string) {
	o.Key = v
}

// GetVariableCollectionId returns the VariableCollectionId field value
func (o *LocalVariable) GetVariableCollectionId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.VariableCollectionId
}

// GetVariableCollectionIdOk returns a tuple with the VariableCollectionId field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetVariableCollectionIdOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.VariableCollectionId, true
}

// SetVariableCollectionId sets field value
func (o *LocalVariable) SetVariableCollectionId(v string) {
	o.VariableCollectionId = v
}

// GetResolvedType returns the ResolvedType field value
func (o *LocalVariable) GetResolvedType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ResolvedType
}

// GetResolvedTypeOk returns a tuple with the ResolvedType field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetResolvedTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ResolvedType, true
}

// SetResolvedType sets field value
func (o *LocalVariable) SetResolvedType(v string) {
	o.ResolvedType = v
}

// GetValuesByMode returns the ValuesByMode field value
func (o *LocalVariable) GetValuesByMode() map[string]LocalVariableValuesByModeValue {
	if o == nil {
		var ret map[string]LocalVariableValuesByModeValue
		return ret
	}

	return o.ValuesByMode
}

// GetValuesByModeOk returns a tuple with the ValuesByMode field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetValuesByModeOk() (map[string]LocalVariableValuesByModeValue, bool) {
	if o == nil {
		return map[string]LocalVariableValuesByModeValue{}, false
	}
	return o.ValuesByMode, true
}

// SetValuesByMode sets field value
func (o *LocalVariable) SetValuesByMode(v map[string]LocalVariableValuesByModeValue) {
	o.ValuesByMode = v
}

// GetRemote returns the Remote field value
func (o *LocalVariable) GetRemote() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.Remote
}

// GetRemoteOk returns a tuple with the Remote field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetRemoteOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Remote, true
}

// SetRemote sets field value
func (o *LocalVariable) SetRemote(v bool) {
	o.Remote = v
}

// GetDescription returns the Description field value
func (o *LocalVariable) GetDescription() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Description
}

// GetDescriptionOk returns a tuple with the Description field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetDescriptionOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Description, true
}

// SetDescription sets field value
func (o *LocalVariable) SetDescription(v string) {
	o.Description = v
}

// GetHiddenFromPublishing returns the HiddenFromPublishing field value
func (o *LocalVariable) GetHiddenFromPublishing() bool {
	if o == nil {
		var ret bool
		return ret
	}

	return o.HiddenFromPublishing
}

// GetHiddenFromPublishingOk returns a tuple with the HiddenFromPublishing field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetHiddenFromPublishingOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return &o.HiddenFromPublishing, true
}

// SetHiddenFromPublishing sets field value
func (o *LocalVariable) SetHiddenFromPublishing(v bool) {
	o.HiddenFromPublishing = v
}

// GetScopes returns the Scopes field value
func (o *LocalVariable) GetScopes() []VariableScope {
	if o == nil {
		var ret []VariableScope
		return ret
	}

	return o.Scopes
}

// GetScopesOk returns a tuple with the Scopes field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetScopesOk() ([]VariableScope, bool) {
	if o == nil {
		return nil, false
	}
	return o.Scopes, true
}

// SetScopes sets field value
func (o *LocalVariable) SetScopes(v []VariableScope) {
	o.Scopes = v
}

// GetCodeSyntax returns the CodeSyntax field value
func (o *LocalVariable) GetCodeSyntax() VariableCodeSyntax {
	if o == nil {
		var ret VariableCodeSyntax
		return ret
	}

	return o.CodeSyntax
}

// GetCodeSyntaxOk returns a tuple with the CodeSyntax field value
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetCodeSyntaxOk() (*VariableCodeSyntax, bool) {
	if o == nil {
		return nil, false
	}
	return &o.CodeSyntax, true
}

// SetCodeSyntax sets field value
func (o *LocalVariable) SetCodeSyntax(v VariableCodeSyntax) {
	o.CodeSyntax = v
}

// GetDeletedButReferenced returns the DeletedButReferenced field value if set, zero value otherwise.
func (o *LocalVariable) GetDeletedButReferenced() bool {
	if o == nil || IsNil(o.DeletedButReferenced) {
		var ret bool
		return ret
	}
	return *o.DeletedButReferenced
}

// GetDeletedButReferencedOk returns a tuple with the DeletedButReferenced field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LocalVariable) GetDeletedButReferencedOk() (*bool, bool) {
	if o == nil || IsNil(o.DeletedButReferenced) {
		return nil, false
	}
	return o.DeletedButReferenced, true
}

// HasDeletedButReferenced returns a boolean if a field has been set.
func (o *LocalVariable) HasDeletedButReferenced() bool {
	if o != nil && !IsNil(o.DeletedButReferenced) {
		return true
	}

	return false
}

// SetDeletedButReferenced gets a reference to the given bool and assigns it to the DeletedButReferenced field.
func (o *LocalVariable) SetDeletedButReferenced(v bool) {
	o.DeletedButReferenced = &v
}

func (o LocalVariable) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o LocalVariable) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["id"] = o.Id
	toSerialize["name"] = o.Name
	toSerialize["key"] = o.Key
	toSerialize["variableCollectionId"] = o.VariableCollectionId
	toSerialize["resolvedType"] = o.ResolvedType
	toSerialize["valuesByMode"] = o.ValuesByMode
	toSerialize["remote"] = o.Remote
	toSerialize["description"] = o.Description
	toSerialize["hiddenFromPublishing"] = o.HiddenFromPublishing
	toSerialize["scopes"] = o.Scopes
	toSerialize["codeSyntax"] = o.CodeSyntax
	if !IsNil(o.DeletedButReferenced) {
		toSerialize["deletedButReferenced"] = o.DeletedButReferenced
	}
	return toSerialize, nil
}

func (o *LocalVariable) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"id",
		"name",
		"key",
		"variableCollectionId",
		"resolvedType",
		"valuesByMode",
		"remote",
		"description",
		"hiddenFromPublishing",
		"scopes",
		"codeSyntax",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varLocalVariable := _LocalVariable{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varLocalVariable)

	if err != nil {
		return err
	}

	*o = LocalVariable(varLocalVariable)

	return err
}

type NullableLocalVariable struct {
	value *LocalVariable
	isSet bool
}

func (v NullableLocalVariable) Get() *LocalVariable {
	return v.value
}

func (v *NullableLocalVariable) Set(val *LocalVariable) {
	v.value = val
	v.isSet = true
}

func (v NullableLocalVariable) IsSet() bool {
	return v.isSet
}

func (v *NullableLocalVariable) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLocalVariable(val *LocalVariable) *NullableLocalVariable {
	return &NullableLocalVariable{value: val, isSet: true}
}

func (v NullableLocalVariable) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLocalVariable) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


