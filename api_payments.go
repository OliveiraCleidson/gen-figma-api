/*
Figma API

This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).

API version: 0.20.0
Contact: support@figma.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PaymentsAPIService PaymentsAPI service
type PaymentsAPIService service

type ApiGetPaymentsRequest struct {
	ctx context.Context
	ApiService *PaymentsAPIService
	pluginPaymentToken *string
	userId *float32
	communityFileId *float32
	pluginId *float32
	widgetId *float32
}

// Short-lived token returned from \&quot;getPluginPaymentTokenAsync\&quot; in the plugin payments API and used to authenticate to this endpoint. Read more about generating this token through \&quot;Calling the Payments REST API from a plugin or widget\&quot; below.
func (r ApiGetPaymentsRequest) PluginPaymentToken(pluginPaymentToken string) ApiGetPaymentsRequest {
	r.pluginPaymentToken = &pluginPaymentToken
	return r
}

// The ID of the user to query payment information about. You can get the user ID by having the user OAuth2 to the Figma REST API.
func (r ApiGetPaymentsRequest) UserId(userId float32) ApiGetPaymentsRequest {
	r.userId = &userId
	return r
}

// The ID of the Community file to query a user&#39;s payment information on. You can get the Community file ID from the file&#39;s Community page (look for the number after \&quot;file/\&quot; in the URL). Provide exactly one of \&quot;community_file_id\&quot;, \&quot;plugin_id\&quot;, or \&quot;widget_id\&quot;.
func (r ApiGetPaymentsRequest) CommunityFileId(communityFileId float32) ApiGetPaymentsRequest {
	r.communityFileId = &communityFileId
	return r
}

// The ID of the plugin to query a user&#39;s payment information on. You can get the plugin ID from the plugin&#39;s manifest, or from the plugin&#39;s Community page (look for the number after \&quot;plugin/\&quot; in the URL). Provide exactly one of \&quot;community_file_id\&quot;, \&quot;plugin_id\&quot;, or \&quot;widget_id\&quot;.
func (r ApiGetPaymentsRequest) PluginId(pluginId float32) ApiGetPaymentsRequest {
	r.pluginId = &pluginId
	return r
}

// The ID of the widget to query a user&#39;s payment information on. You can get the widget ID from the widget&#39;s manifest, or from the widget&#39;s Community page (look for the number after \&quot;widget/\&quot; in the URL). Provide exactly one of \&quot;community_file_id\&quot;, \&quot;plugin_id\&quot;, or \&quot;widget_id\&quot;.
func (r ApiGetPaymentsRequest) WidgetId(widgetId float32) ApiGetPaymentsRequest {
	r.widgetId = &widgetId
	return r
}

func (r ApiGetPaymentsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetPaymentsExecute(r)
}

/*
GetPayments Get payments

There are two methods to query for a user's payment information on a plugin, widget, or Community file. The first method, using plugin payment tokens, is typically used when making queries from a plugin's or widget's code. The second method, providing a user ID and resource ID, is typically used when making queries from anywhere else.

Note that you can only query for resources that you own. In most cases, this means that you can only query resources that you originally created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPaymentsRequest
*/
func (a *PaymentsAPIService) GetPayments(ctx context.Context) ApiGetPaymentsRequest {
	return ApiGetPaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *PaymentsAPIService) GetPaymentsExecute(r ApiGetPaymentsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentsAPIService.GetPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pluginPaymentToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "plugin_payment_token", r.pluginPaymentToken, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "form", "")
	}
	if r.communityFileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "community_file_id", r.communityFileId, "form", "")
	}
	if r.pluginId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "plugin_id", r.pluginId, "form", "")
	}
	if r.widgetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "widget_id", r.widgetId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["PersonalAccessToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Figma-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponsePayloadWithErrorBoolean
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorResponsePayloadWithErrorBoolean
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponsePayloadWithErrorBoolean
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
